<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>lys.slør</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    /* Button overlay for requesting motion permission on mobile */
    #motionBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 1em 2em;
      font-size: 1.2em;
      background-color: rgba(0,0,0,0.8);
      color: #fff;
      border: 2px solid #fff;
      border-radius: 5px;
      z-index: 1000;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="shaderCanvas"></canvas>
  <button id="motionBtn">Click for Device Motion</button>
  <script>
    class OrganicFluidTransition {
      constructor() {
        this.canvas = document.getElementById('shaderCanvas');
        this.gl = this.canvas.getContext('webgl2');
        if (!this.gl) {
          alert('Your browser does not support WebGL2');
          return;
        }
        
        // Determine if mobile (for later time scaling)
        this.isMobile = (window.DeviceOrientationEvent !== undefined);
        
        // Base images – using the original 7 images.
        this.imagePaths = ['1.JPG','2.JPG','3.JPG','4.JPG','5.JPG','6.JPG','7.JPG'];
        
        // Create the video element for displacement.
        this.video = document.createElement('video');
        this.video.src = "dispvid4.mp4";
        this.video.loop = true;
        this.video.muted = true;
        this.video.playsInline = true;
        this.video.play().catch(err => console.error("Video play error:", err));
        
        // Vertex shader (simple passthrough)
        this.vertexShaderSource = `#version 300 es
          in vec4 a_position;
          in vec2 a_texCoord;
          out vec2 v_texCoord;
          void main() {
            gl_Position = a_position;
            v_texCoord = a_texCoord;
          }
        `;
        
        // Fragment shader integrating the base transition and the new fractal shader effect.
        this.fragmentShaderSource = `#version 300 es
          precision highp float;
          
          #define PI 3.141592
          
          // Uniforms
          uniform sampler2D u_image0;
          uniform sampler2D u_image1;
          uniform sampler2D u_dispVideo;
          uniform vec2 u_resolution;
          uniform vec2 u_mouse;
          uniform float u_time;
          uniform float u_transitionProgress;
          uniform float u_dispAmount;
          uniform float u_dispScale;
          
          in vec2 v_texCoord;
          out vec4 outColor;
          
          ///////////////////////////
          // Base Transition Effect//
          ///////////////////////////
          vec4 baseTransition() {
            vec2 timeOffset = vec2(0.015 * sin(u_time * 0.25), 0.015 * cos(u_time * 0.25)); // Slower, more subtle movement
            vec2 dispCoord = v_texCoord * u_dispScale + timeOffset;
            
            // Process the displacement video texture with watermark removal
            vec2 videoDisp = texture(u_dispVideo, dispCoord).rg;
            
            // Mask out the top-right corner watermark region
            // Adjust these values based on the exact watermark position and size
            float watermarkMask = 1.0;
            if (dispCoord.x > 0.7 && dispCoord.y < 0.3) {
                // Apply a smooth mask to avoid hard edges
                float xFade = smoothstep(0.7, 0.9, dispCoord.x);
                float yFade = smoothstep(0.3, 0.1, dispCoord.y);
                watermarkMask = 1.0 - (xFade * yFade);
                
                // Replace watermark area with average displacement or neutral value
                videoDisp = mix(videoDisp, vec2(0.5, 0.5), 1.0 - watermarkMask);
            }
            
            float dynamicDisp = u_dispAmount * (1.0 + 0.4 * sin(u_time * 0.15)); // Even slower displacement modulation
            vec2 displacement = (videoDisp - 0.5) * dynamicDisp * 1.5 * watermarkMask; // Increased to emphasize displacement map effect
            
            float baseProg = smoothstep(0.0, 1.0, u_transitionProgress);
            float waveFactor = abs(((videoDisp.r + videoDisp.g) * 0.5) - 0.5) * 2.0;
            float smoothProg = mix(baseProg, waveFactor, 0.6); // Increase displacement influence on transition
            
            // Remap the mix factor for an extra-smooth fade.
            float smoothFade = smoothstep(0.1, 0.9, smoothProg); // Even wider smoothstep for ultra-smooth transitions
            
            vec2 displacedUV0 = clamp(v_texCoord + displacement * (1.0 - smoothProg), 0.0, 1.0);
            vec2 displacedUV1 = clamp(v_texCoord - displacement * smoothProg, 0.0, 1.0);
            
            vec4 color0 = texture(u_image0, displacedUV0);
            vec4 color1 = texture(u_image1, displacedUV1);
            return mix(color0, color1, smoothFade);
          }
          
          /////////////////////////////////////
          // New Shader Effect (Fractal HSV) //
          /////////////////////////////////////
          
          // HSV conversion function.
          vec3 hsv(float h, float s, float v) {
            return mix(vec3(1.0), clamp((abs(fract(h + vec3(3.0,2.0,1.0)/3.0)*6.0-3.0)-1.0), 0.0, 1.0), s) * v;
          }
          
          // Main formula function.
          vec3 formula(in vec2 p, in vec2 c) {
            const float n = 2.0;
            const int iters = 12;
            float time = u_time * 0.1;
            vec3 col = vec3(0.0);
            float t = 1.0;
            float dpp = dot(p, p);
            float lp = sqrt(dpp);
            float r = smoothstep(0.0, 0.2, lp);
            
            for (int i = 0; i < iters; i++) {
              p = abs(mod(p/dpp + c, n) - n/2.0);
              dpp = dot(p, p);
              lp = sqrt(dpp);
              
              // Variable width lines
              t *= smoothstep(0.0, 0.01, abs(n/2.0 - p.x) * lp)
                 * smoothstep(0.0, 0.01, abs(n/2.0 - p.y) * lp)
                 * smoothstep(0.0, 0.01, abs(p.x) * 2.0)
                 * smoothstep(0.0, 0.01, abs(p.y) * 2.0);
              
              // Fade high density areas.
              r *= smoothstep(0.0, 0.2, lp);
              
              // Accumulate color using hsv.
              col += hsv(1.0 - max(p.x, p.y) + t * 2.0 + time, 2.0 - lp + t, r);
            }
            return (-cos(col / 4.0) * 0.5 + 0.5) * t;
          }
          
          // New shader effect wrapped as a function.
          vec3 newShaderEffect(vec2 fragCoord) {
            vec2 p = -1.0 + 2.0 * fragCoord / u_resolution;
            p.x *= u_resolution.x / u_resolution.y;
            p *= 2.0;
            const vec2 e = vec2(0.06545465634, -0.05346356485);
            vec2 c = u_time * e;
            vec3 col = vec3(0.0);
            const float blursamples = 4.0;
            float sbs = sqrt(blursamples);
            float mbluramount = 1.0 / u_resolution.x / length(e) / blursamples * 2.0;
            float aabluramount = 1.0 / u_resolution.x / sbs * 4.0;
            for (float b = 0.0; b < blursamples; b++) {
              col += formula(
                p + vec2(mod(b, sbs) * aabluramount, floor(b / sbs) * aabluramount),
                c + e * mbluramount * b);
            }
            col /= blursamples;
            return col;
          }
          
          ////////////////////////////////
          // Custom Blending Functions  //
          ////////////////////////////////
          
          // Soft light blend
          vec3 softLightBlend(vec3 base, vec3 blend) {
            return vec3(
              base.r < 0.5
                ? (2.0 * base.r * blend.r + base.r * base.r * (1.0 - 2.0 * blend.r))
                : (sqrt(base.r) * (2.0 * blend.r - 1.0) + 2.0 * base.r * (1.0 - blend.r)),
              base.g < 0.5
                ? (2.0 * base.g * blend.g + base.g * base.g * (1.0 - 2.0 * blend.g))
                : (sqrt(base.g) * (2.0 * blend.g - 1.0) + 2.0 * base.g * (1.0 - blend.g)),
              base.b < 0.5
                ? (2.0 * base.b * blend.b + base.b * base.b * (1.0 - 2.0 * blend.b))
                : (sqrt(base.b) * (2.0 * blend.b - 1.0) + 2.0 * base.b * (1.0 - blend.b))
            );
          }
          
          // Screen blend mode - brightens and creates shine
          vec3 screenBlend(vec3 base, vec3 blend) {
            return 1.0 - (1.0 - base) * (1.0 - blend);
          }
          
          // Color dodge blend - creates intense highlights
          vec3 colorDodgeBlend(vec3 base, vec3 blend) {
            return vec3(
              blend.r == 1.0 ? 1.0 : min(1.0, base.r / (1.0 - blend.r)),
              blend.g == 1.0 ? 1.0 : min(1.0, base.g / (1.0 - blend.g)),
              blend.b == 1.0 ? 1.0 : min(1.0, base.b / (1.0 - blend.b))
            );
          }
          
          // Enhanced labradorite/opal effect function with SUBTLER flash effect
          vec3 labradoriteFlash(vec3 baseColor, vec2 coords, vec2 displacement, float time) {
            // Create structured patterns that mimic the crystal planes of labradorite
            // These will determine where the flash occurs based on viewing angle (displacement)
            
            // Create layered patterns at different scales to mimic labradorite crystal structure
            float pattern1 = sin(coords.x * 12.0 + displacement.x * 16.0 + time * 0.2) * 
                             cos(coords.y * 10.0 + displacement.y * 14.0 - time * 0.15);
            
            float pattern2 = sin((coords.x + coords.y) * 18.0 + displacement.y * 20.0 - time * 0.1) * 
                             cos((coords.x - coords.y) * 15.0 + displacement.x * 18.0 + time * 0.05);
                             
            float pattern3 = sin(coords.x * 25.0 - coords.y * 20.0 + displacement.x * 10.0 - time * 0.07) *
                             cos(coords.y * 30.0 + displacement.y * 12.0 + time * 0.12);
            
            // Combine patterns with different weights
            float combinedPattern = pattern1 * 0.5 + pattern2 * 0.3 + pattern3 * 0.2;
            
            // Create planes/facets where the flash appears (like real labradorite crystal structure)
            // The threshold creates sharp transitions like real labradorite flash
            // Make the flash more selective with a higher threshold
            float flashMask = smoothstep(0.3, 0.6, abs(combinedPattern)); // More selective flash (was 0.1, 0.4)
            
            // Add smaller details/fracturing within the flash areas
            float detailPattern = sin(coords.x * 80.0 + coords.y * 70.0 + time * 0.3) * 0.5 + 0.5;
            flashMask *= (0.8 + detailPattern * 0.2);
            
            // Reduce the final flash mask intensity
            flashMask *= 0.6; // Overall reduction in flash intensity
            
            // Define a wider color palette based on the examples - but with slightly more subdued colors
            vec3 deepBlue = vec3(0.0, 0.2, 0.7);      // Deep blue (slightly less intense)
            vec3 aquaBlue = vec3(0.0, 0.6, 0.9);      // Aqua/cyan blue (slightly less intense)
            vec3 goldYellow = vec3(0.9, 0.7, 0.0);    // Gold/yellow (slightly less intense)
            vec3 emeraldGreen = vec3(0.0, 0.7, 0.4);  // Emerald green (slightly less intense)
            vec3 violetPurple = vec3(0.4, 0.0, 0.7);  // Violet/purple (slightly less intense)
            vec3 peachGold = vec3(0.9, 0.5, 0.3);     // Peachy gold (slightly less intense)
            
            // Use both displacement components to create color variation
            // This makes the colors change based on viewing angle
            float colorVariation1 = displacement.x * 0.6 + displacement.y * 0.4;
            float colorVariation2 = displacement.y * 0.7 - displacement.x * 0.3;
            
            // Create color changing effect
            float colorSelector = fract(colorVariation1 * 2.0 + time * 0.05);
            float colorBlender = fract(colorVariation2 * 1.5 - time * 0.03);
            
            // Allow for multiple colors to appear simultaneously on different "planes"
            vec3 flashColor1, flashColor2;
            
            // First color selection
            if (colorSelector < 0.2) {
                flashColor1 = mix(deepBlue, aquaBlue, colorSelector * 5.0);
            } else if (colorSelector < 0.4) {
                flashColor1 = mix(aquaBlue, emeraldGreen, (colorSelector - 0.2) * 5.0);
            } else if (colorSelector < 0.6) {
                flashColor1 = mix(emeraldGreen, goldYellow, (colorSelector - 0.4) * 5.0);
            } else if (colorSelector < 0.8) {
                flashColor1 = mix(goldYellow, peachGold, (colorSelector - 0.6) * 5.0);
            } else {
                flashColor1 = mix(peachGold, violetPurple, (colorSelector - 0.8) * 5.0);
            }
            
            // Second color selection (offset for different pattern)
            if (colorBlender < 0.2) {
                flashColor2 = mix(violetPurple, peachGold, colorBlender * 5.0);
            } else if (colorBlender < 0.4) {
                flashColor2 = mix(peachGold, goldYellow, (colorBlender - 0.2) * 5.0);
            } else if (colorBlender < 0.6) {
                flashColor2 = mix(goldYellow, emeraldGreen, (colorBlender - 0.4) * 5.0);
            } else if (colorBlender < 0.8) {
                flashColor2 = mix(emeraldGreen, aquaBlue, (colorBlender - 0.6) * 5.0);
            } else {
                flashColor2 = mix(aquaBlue, deepBlue, (colorBlender - 0.8) * 5.0);
            }
            
            // Mix the two flash colors based on pattern3 for more complexity
            vec3 finalFlashColor = mix(flashColor1, flashColor2, pattern3 * 0.5 + 0.5);
            
            // Create the distinctive metallic sheen by boosting brightness based on flash mask
            // Reduce the brightness boost for subtlety
            finalFlashColor = finalFlashColor * (1.0 + flashMask * 0.5); // Reduced from 0.7 to 0.5
            
            // Add brightness variation within the flash
            float brightnessVariation = sin(coords.x * 40.0 + coords.y * 35.0 + time * 0.2) * 0.5 + 0.5;
            finalFlashColor *= (0.9 + brightnessVariation * 0.2); // Reduced variation from 0.4 to 0.2
            
            // Create the final flash effect with a gentler screen blend
            vec3 flashBlend = 1.0 - (1.0 - baseColor) * (1.0 - finalFlashColor * 0.6); // Reduced from 0.8 to 0.6
            return mix(baseColor, flashBlend, flashMask * 0.5); // Reduced from 0.8 to 0.5
          }
          
          //////////////////////////////
          // Main Fragment Function   //
          //////////////////////////////
          void main() {
            vec4 baseColor = baseTransition();
            vec3 fractalEffect = newShaderEffect(gl_FragCoord.xy);
            
            // Get displacement for effect masking and labradorite flash
            vec2 dispCoord = v_texCoord * u_dispScale;
            vec2 videoDisp = texture(u_dispVideo, dispCoord).rg;
            vec2 normalizedDisp = videoDisp * 2.0 - 1.0; // Convert to -1 to 1 range
            
            // Create the primary soft light blend between base and fractal
            vec3 softLight = softLightBlend(baseColor.rgb, fractalEffect);
            
            // Apply fractal enhancement - boost contrast and intensity
            fractalEffect = pow(fractalEffect * 1.2, vec3(0.85)); // Boost brightness & contrast
            
            // Apply enhanced labradorite flash effect with REDUCED strength
            vec3 withLabradorite = labradoriteFlash(
                softLight, 
                v_texCoord,
                normalizedDisp * 0.7, // Reduce displacement influence
                u_time
            );
            
            // Blend the labradorite effect with the original at a much lower intensity
            withLabradorite = mix(softLight, withLabradorite, 0.3); // Significantly reduce intensity from 1.0 to 0.3
            
            // Add fractal detail to the labradorite areas
            float enhancementMask = length(fractalEffect) * 0.7; // Use overall fractal strength
            enhancementMask = pow(enhancementMask, 1.5); // Increase contrast of mask
            
            // Create highlight areas with color dodge for extra dimension and shine
            vec3 highlights = colorDodgeBlend(withLabradorite, fractalEffect * 0.6);
            
            // Mix in more highlight intensity in areas where fractal is strong, but at reduced strength
            vec3 enhanced = mix(withLabradorite, highlights, enhancementMask * 0.15); // Reduced from 0.4 to 0.15
            
            // Final luminosity boost in certain areas for subtle "internal glow", significantly reduced
            float luminosityMask = dot(fractalEffect, vec3(0.299, 0.587, 0.114));
            luminosityMask = pow(luminosityMask, 2.0) * normalizedDisp.x * normalizedDisp.y;
            enhanced = mix(enhanced, screenBlend(enhanced, vec3(0.9, 0.95, 1.0)), abs(luminosityMask) * 0.1); // Reduced from 0.3 to 0.1
            
            // Use a more subtle contrast adjustment
            float contrastAdjust = 0.97 + abs(normalizedDisp.x * normalizedDisp.y) * 0.05; // Less contrast adjustment
            vec3 finalColor = pow(enhanced, vec3(contrastAdjust));
            
            outColor = vec4(finalColor, baseColor.a);
          }
        `;
        
        this.program = this.createShaderProgram();
        this.setupBuffers();
        this.loadTextures();
        this.loadDispTextures();
        this.setupEventListeners();
        this.startAnimation();
      }
      
      createShaderProgram() {
        const gl = this.gl;
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, this.vertexShaderSource);
        gl.compileShader(vertexShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
        }
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, this.fragmentShaderSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
        }
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program linking error:', gl.getProgramInfoLog(program));
        }
        return program;
      }
      
      setupBuffers() {
        const gl = this.gl;
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
          -1.0, -1.0,
           1.0, -1.0,
          -1.0,  1.0,
          -1.0,  1.0,
           1.0, -1.0,
           1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        
        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        const texCoords = [
          0.0, 0.0,
          1.0, 0.0,
          0.0, 1.0,
          0.0, 1.0,
          1.0, 0.0,
          1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
        
        gl.useProgram(this.program);
        const posLoc = gl.getAttribLocation(this.program, 'a_position');
        const texLoc = gl.getAttribLocation(this.program, 'a_texCoord');
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.enableVertexAttribArray(texLoc);
        gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
      }
      
      loadTextures() {
        const gl = this.gl;
        this.textures = [];
        this.images = [];
        this.imagePaths.forEach(path => {
          const img = new Image();
          img.src = path;
          this.images.push(img);
        });
        Promise.all(this.images.map(img => new Promise(resolve => {
          if (img.complete) resolve();
          else img.onload = resolve;
        })))
        .then(() => {
          this.images.forEach(image => {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            this.textures.push(texture);
          });
          this.resizeCanvas();
        })
        .catch(err => console.error('Error loading base images:', err));
      }
      
      loadDispTextures() {
        const gl = this.gl;
        this.dispTextures = [];
        this.dispVideoTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.dispVideoTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 480, 270, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        this.dispTextures.push(this.dispVideoTexture);
      }
      
      updateVideoTexture() {
        const gl = this.gl;
        if (this.video.readyState >= this.video.HAVE_CURRENT_DATA) {
          gl.bindTexture(gl.TEXTURE_2D, this.dispVideoTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.video);
        }
      }
      
      setupEventListeners() {
        this.mouseX = 0;
        this.mouseY = 0;
        window.addEventListener('mousemove', e => {
          this.mouseX = e.clientX;
          this.mouseY = e.clientY;
          this.requestRender();
        });
        if (window.DeviceOrientationEvent) {
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            const motionBtn = document.getElementById('motionBtn');
            motionBtn.style.display = 'block';
            motionBtn.addEventListener('click', () => {
              DeviceOrientationEvent.requestPermission()
                .then(response => {
                  if (response === 'granted') {
                    window.addEventListener('deviceorientation', e => {
                      let gamma = e.gamma || 0;
                      let beta = e.beta || 0;
                      this.mouseX = ((gamma + 90) / 180) * window.innerWidth;
                      this.mouseY = ((beta + 180) / 360) * window.innerHeight;
                      this.requestRender();
                    });
                    motionBtn.style.display = 'none';
                  }
                })
                .catch(console.error);
            });
          } else {
            window.addEventListener('deviceorientation', e => {
              let gamma = e.gamma || 0;
              let beta = e.beta || 0;
              this.mouseX = ((gamma + 90) / 180) * window.innerWidth;
              this.mouseY = ((beta + 180) / 360) * window.innerHeight;
              this.requestRender();
            });
          }
        }
        window.addEventListener('resize', () => {
          this.resizeCanvas();
          this.requestRender();
        });
      }
      
      resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      }
      
      requestRender() {
        if (!this.renderRequested) {
          this.renderRequested = true;
          requestAnimationFrame(() => this.render());
        }
      }
      
      startAnimation() {
        this.currentImageIndex = 0;
        this.nextImageIndex = 1;
        this.transitionProgress = 0;
        this.currentTransition = 0.0;
        this.startTime = performance.now();
        this.requestRender();
      }
      
      render() {
        const gl = this.gl;
        this.renderRequested = false;
        this.updateVideoTexture();
        
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        if (!this.textures || this.textures.length < 2) return;
        
        gl.useProgram(this.program);
        
        // Normalize mouse position and smooth it over a much wider range
        const mouseXNorm = this.mouseX / this.canvas.width;
        
        // Apply a more gradual mapping to stretch out transitions across the screen
        // This uses only the middle 60% of the screen for transitions (20%-80%) making them more gradual
        const adjustedMouseX = Math.max(0, Math.min(1, (mouseXNorm - 0.2) / 0.6));
        
        const imageIndex = Math.min(
          Math.floor(adjustedMouseX * this.imagePaths.length),
          this.imagePaths.length - 1
        );
        const nextImageIndex = (imageIndex + 1) % this.imagePaths.length;
        const segmentWidth = 1 / this.imagePaths.length;
        const segmentProgress = (adjustedMouseX - (imageIndex * segmentWidth)) / segmentWidth;
        
        // Extremely gradual transition - dramatically reduced rate
        this.currentTransition += (segmentProgress - this.currentTransition) * 0.002;
        
        const resLoc = gl.getUniformLocation(this.program, 'u_resolution');
        const mouseLoc = gl.getUniformLocation(this.program, 'u_mouse');
        const timeLoc = gl.getUniformLocation(this.program, 'u_time');
        const transLoc = gl.getUniformLocation(this.program, 'u_transitionProgress');
        const img0Loc = gl.getUniformLocation(this.program, 'u_image0');
        const img1Loc = gl.getUniformLocation(this.program, 'u_image1');
        const dispVideoLoc = gl.getUniformLocation(this.program, 'u_dispVideo');
        const dispAmountLoc = gl.getUniformLocation(this.program, 'u_dispAmount');
        const dispScaleLoc = gl.getUniformLocation(this.program, 'u_dispScale');
        
        gl.uniform2f(resLoc, this.canvas.width, this.canvas.height);
        gl.uniform2f(mouseLoc, this.mouseX, this.mouseY);
        const elapsedTime = (performance.now() - this.startTime) / 1000;
        gl.uniform1f(timeLoc, elapsedTime);
        gl.uniform1f(transLoc, this.currentTransition);
        
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.textures[imageIndex]);
        gl.uniform1i(img0Loc, 0);
        
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.textures[nextImageIndex]);
        gl.uniform1i(img1Loc, 1);
        
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, this.dispTextures[0]);
        gl.uniform1i(dispVideoLoc, 2);
        
        gl.uniform1f(dispAmountLoc, 0.08); // Increased displacement amount
        gl.uniform1f(dispScaleLoc, 1.0);
        
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
    }
    
    window.addEventListener('load', () => {
      new OrganicFluidTransition();
    });
  </script>
</body>
</html>