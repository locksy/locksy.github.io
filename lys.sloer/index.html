<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>lys.sl√∏r</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    /* Hide the video element */
    #videoDisp {
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="shaderCanvas"></canvas>
  <video id="videoDisp" loop muted playsinline>
    <source src="/maps/dispvid4.mp4" type="video/mp4">
  </video>

  <script>
    class OrganicFluidTransition {
      constructor() {
        this.canvas = document.getElementById('shaderCanvas');
        this.gl = this.canvas.getContext('webgl2');
        if (!this.gl) {
          alert('WebGL2 not supported');
          return;
        }

        this.imagePaths = ['1.JPG', '2.JPG', '3.JPG', '4.JPG', '5.JPG', '6.JPG', '7.JPG'];
        this.video = document.getElementById('videoDisp');
        this.video.play();

        this.isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
        this.tiltX = 0; // For horizontal tilt (gamma)
        this.tiltY = 0; // For vertical tilt (beta)
        this.shakeIntensity = 0; // For shake detection

        this.setupShaders();
        this.setupBuffers();
        this.loadTextures();
        this.setupEventListeners();
        this.startAnimation();
      }

      setupShaders() {
        const vertexShaderSource = `#version 300 es
          in vec4 a_position;
          in vec2 a_texCoord;
          out vec2 v_texCoord;
          void main() {
            gl_Position = a_position;
            v_texCoord = a_texCoord;
          }
        `;

        const fragmentShaderSource = `#version 300 es
          precision highp float;

          uniform sampler2D u_image0;
          uniform sampler2D u_image1;
          uniform sampler2D u_dispVideo;

          uniform vec2 u_resolution;
          uniform float u_time;
          uniform float u_transitionProgress;
          uniform float u_dispAmount;
          uniform float u_dispScale;
          uniform float u_rgbShift;

          in vec2 v_texCoord;
          out vec4 outColor;

          void main() {
            vec2 timeOffset = vec2(0.02 * sin(u_time * 0.5), 0.02 * cos(u_time * 0.5));
            vec2 dispCoord = v_texCoord * u_dispScale + timeOffset;

            vec2 videoDisp = texture(u_dispVideo, dispCoord).rg;
            vec2 displacement = (videoDisp - 0.5) * u_dispAmount;

            vec2 displacedUV0 = clamp(v_texCoord + displacement * (1.0 - u_transitionProgress), 0.0, 1.0);
            vec2 displacedUV1 = clamp(v_texCoord - displacement * u_transitionProgress, 0.0, 1.0);
            vec4 color0 = texture(u_image0, displacedUV0);
            vec4 color1 = texture(u_image1, displacedUV1);
            vec4 baseColor = mix(color0, color1, u_transitionProgress);

            // RGB Shift based on shake intensity
            float shiftAmount = u_rgbShift * 0.002;
            vec4 shiftedR = texture(u_image0, displacedUV0 + vec2(shiftAmount, 0.0));
            vec4 shiftedB = texture(u_image1, displacedUV1 - vec2(shiftAmount, 0.0));

            vec3 finalColor = vec3(
              shiftedR.r,
              baseColor.g,
              shiftedB.b
            );

            outColor = vec4(finalColor, baseColor.a);
          }
        `;

        const gl = this.gl;
        this.program = gl.createProgram();
        const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          console.error('Program linking error:', gl.getProgramInfoLog(this.program));
        }
      }

      compileShader(type, source) {
        const shader = this.gl.createShader(type);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
          console.error('Shader error:', this.gl.getShaderInfoLog(shader));
        }
        return shader;
      }

      setupBuffers() {
        const gl = this.gl;
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        const texCoords = [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);
      }

      loadTextures() {
        this.textures = [];
        this.images = this.imagePaths.map((path) => {
          const img = new Image();
          img.src = path;
          return img;
        });

        this.images.forEach((image, i) => {
          image.onload = () => {
            const texture = this.gl.createTexture();
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
            this.textures[i] = texture;
          };
        });

        this.dispVideoTexture = this.gl.createTexture();
      }

      setupEventListeners() {
        if (this.isMobile) {
          window.addEventListener("deviceorientation", (event) => {
            this.tiltX = event.gamma / 30; // Normalize left-right tilt
            this.tiltY = event.beta / 30;  // Normalize up-down tilt
          });

          window.addEventListener("devicemotion", (event) => {
            const accel = event.accelerationIncludingGravity;
            const shakeStrength = Math.abs(accel.x) + Math.abs(accel.y) + Math.abs(accel.z);
            this.shakeIntensity = Math.min(shakeStrength / 20, 1.0); // Scale between 0-1
          });
        }
      }

      updateVideoTexture() {
        if (this.video.readyState >= this.video.HAVE_CURRENT_DATA) {
          this.gl.bindTexture(this.gl.TEXTURE_2D, this.dispVideoTexture);
          this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.video);
        }
      }

      render() {
        this.updateVideoTexture();
        this.gl.useProgram(this.program);

        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_transitionProgress'), this.tiltX);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_dispAmount'), this.tiltY);
        this.gl.uniform1f(this.gl.getUniformLocation(this.program, 'u_rgbShift'), this.shakeIntensity);

        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
      }
    }

    window.addEventListener("load", () => new OrganicFluidTransition());
  </script>
</body>
</html>
