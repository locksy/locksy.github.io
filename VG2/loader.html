<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Virgo Gabrielle - Loader</title>
    
    <style>
        @font-face {
            font-family: 'BubbleCore';
            src: url('./BubbleCore-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            background: #000000;
            overflow: hidden;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Liquid Glass Text Overlay */
        .glass-text-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            gap: 10px;
        }

        .glass-text {
            font-family: 'BubbleCore', 'Arial Black', sans-serif;
            text-transform: lowercase;
            position: relative;
            /* Glass distortion via SVG filter */
            -webkit-backdrop-filter: url(#liquid-glass-filter) blur(0.5px) brightness(1.05) saturate(1.2);
            backdrop-filter: url(#liquid-glass-filter) blur(0.5px) brightness(1.05) saturate(1.2);
            /* Subtle text styling */
            color: rgba(255, 255, 255, 0.06);
            text-shadow: 
                0 1px 2px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(100, 150, 255, 0.1);
            -webkit-text-stroke: 0.5px rgba(180, 200, 255, 0.35);
        }

        .glass-text-top {
            font-size: clamp(60px, 15vw, 140px);
        }

        .glass-text-bottom {
            font-size: clamp(45px, 11vw, 105px);
        }

        /* Loading / Status Indicator */
        .status-display {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            width: 100%;
            pointer-events: none;
        }

        .loading-text {
            font-size: 12px;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            animation: pulse 2s infinite;
        }

        .input-indicators {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .indicator {
            font-size: 9px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            transition: color 0.3s, opacity 0.3s;
            opacity: 0.5;
        }

        .indicator.active {
            color: #c9a962;
            opacity: 1;
        }

        .indicator::before {
            content: '';
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: currentColor;
            margin-right: 6px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- SVG Filter for Liquid Glass Effect -->
    <svg style="position: absolute; width: 0; height: 0;" aria-hidden="true">
        <defs>
            <filter id="liquid-glass-filter" x="-10%" y="-10%" width="120%" height="120%" color-interpolation-filters="sRGB">
                <!-- Generate organic noise pattern -->
                <feTurbulence 
                    type="fractalNoise" 
                    baseFrequency="0.012 0.012" 
                    numOctaves="3" 
                    seed="15" 
                    result="noise"
                />
                <!-- Smooth the noise -->
                <feGaussianBlur in="noise" stdDeviation="1.5" result="smoothNoise"/>
                <!-- Apply displacement -->
                <feDisplacementMap 
                    in="SourceGraphic" 
                    in2="smoothNoise" 
                    scale="12" 
                    xChannelSelector="R" 
                    yChannelSelector="G"
                    result="displaced"
                />
            </filter>
        </defs>
    </svg>

    <div id="canvas-container"></div>
    
    <!-- Glass Text Overlay -->
    <div class="glass-text-container" id="glassTextContainer">
        <div class="glass-text glass-text-top">virgo</div>
        <div class="glass-text glass-text-bottom">gabrielle</div>
    </div>
    
    <div class="status-display">
        <div class="loading-text" id="mainStatus">LOADING</div>
        <div class="input-indicators">
            <div class="indicator" id="ind-manual">Touch/Mouse</div>
            <div class="indicator" id="ind-sensor">Sensor</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/parallax-effect/dist/parallax-effect.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const CONFIG = {
            imagePath: './new-img.png',
            depthPath: './new-depth.png',
            
            parallaxStrength: 25,
            inputSensitivity: 10,
            smoothing: 0.25,
            
            chromaticAberration: 0.015,
            noiseAmount: 0.03,
            
            zoomLevel: 0.85,
            
            // Title parallax (subtle movement)
            titleParallaxStrength: 8,
            
            // Input timeout (ms)
            manualInputTimeout: 2000,
        };

        // ============================================================
        // GLOBAL STATE
        // ============================================================
        const state = {
            sensor: { x: 0, y: 0, available: false },
            manual: { x: 0, y: 0, lastActivity: 0 },
            viewX: 0, 
            viewY: 0, 
            currentInput: 'none',
        };

        // ============================================================
        // THREE.JS SETUP (Background only)
        // ============================================================
        let scene, camera, renderer;
        let backgroundMesh;
        let backgroundTexture, depthTexture;
        let time = 0;

        const backgroundVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const backgroundFragmentShader = `
            precision highp float;
            varying vec2 vUv;
            
            uniform sampler2D uImage;
            uniform sampler2D uDepth;
            uniform vec2 uViewOffset;
            uniform float uStrength;
            uniform float uZoom;
            uniform float uCA;
            uniform float uNoise;
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec2 uImageResolution;
            
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            void main() {
                // Aspect-correct UVs (contain mode)
                float screenAspect = uResolution.x / uResolution.y;
                float imageAspect = uImageResolution.x / uImageResolution.y;
                
                vec2 scale;
                if (screenAspect > imageAspect) {
                    scale = vec2(imageAspect / screenAspect, 1.0);
                } else {
                    scale = vec2(1.0, screenAspect / imageAspect);
                }
                
                vec2 uv = (vUv - 0.5) / scale + 0.5;
                
                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    return;
                }
                
                float margin = (1.0 - uZoom) * 0.5;
                uv = uv * uZoom + margin;
                
                float depth = texture2D(uDepth, uv).r;
                vec2 baseOffset = -uViewOffset * depth * uStrength;
                
                float distortion = length(uViewOffset) * 2.0;
                float dynamicCA = uCA * (1.0 + distortion);
                
                vec2 offsetR = baseOffset + uViewOffset * dynamicCA * depth;
                vec2 offsetB = baseOffset - uViewOffset * dynamicCA * depth;
                
                float r = texture2D(uImage, uv + offsetR).r;
                float g = texture2D(uImage, uv + baseOffset).g;
                float b = texture2D(uImage, uv + offsetB).b;
                
                vec3 color = vec3(r, g, b);
                
                float noise = hash(floor(vUv * uResolution * 0.5) + uTime * 0.1) * 2.0 - 1.0;
                color += noise * uNoise;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        async function loadTexture(url) {
            return new Promise((resolve, reject) => {
                new THREE.TextureLoader().load(url, resolve, undefined, reject);
            });
        }

        async function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
            camera.position.z = 1;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            try {
                backgroundTexture = await loadTexture(CONFIG.imagePath);
                depthTexture = await loadTexture(CONFIG.depthPath);
                
                const bgGeometry = new THREE.PlaneGeometry(2, 2);
                const bgMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uImage: { value: backgroundTexture },
                        uDepth: { value: depthTexture },
                        uViewOffset: { value: new THREE.Vector2(0, 0) },
                        uStrength: { value: CONFIG.parallaxStrength / 1000 },
                        uZoom: { value: CONFIG.zoomLevel },
                        uCA: { value: CONFIG.chromaticAberration },
                        uNoise: { value: CONFIG.noiseAmount },
                        uTime: { value: 0 },
                        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        uImageResolution: { value: new THREE.Vector2(backgroundTexture.image.width, backgroundTexture.image.height) }
                    },
                    vertexShader: backgroundVertexShader,
                    fragmentShader: backgroundFragmentShader
                });
                backgroundMesh = new THREE.Mesh(bgGeometry, bgMaterial);
                scene.add(backgroundMesh);
                
                document.getElementById('mainStatus').innerText = 'READY';
                
            } catch (e) {
                console.error('Failed to initialize:', e);
                document.getElementById('mainStatus').innerText = 'ERROR';
            }
            
            window.addEventListener('resize', onResize);
        }

        function onResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            renderer.setSize(width, height);
            
            if (backgroundMesh) {
                backgroundMesh.material.uniforms.uResolution.value.set(width, height);
            }
        }

        function renderThreeJS() {
            time += 0.016;
            
            if (backgroundMesh) {
                backgroundMesh.material.uniforms.uViewOffset.value.set(state.viewX, state.viewY);
                backgroundMesh.material.uniforms.uTime.value = time;
            }
            
            renderer.render(scene, camera);
        }

        // ============================================================
        // TEXT PARALLAX
        // ============================================================
        function updateTextParallax() {
            const container = document.getElementById('glassTextContainer');
            const offsetX = state.viewX * CONFIG.titleParallaxStrength;
            const offsetY = -state.viewY * CONFIG.titleParallaxStrength;
            container.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }

        // ============================================================
        // INPUT HANDLERS
        // ============================================================
        
        function updateInputIndicators() {
            const manualInd = document.getElementById('ind-manual');
            const sensorInd = document.getElementById('ind-sensor');
            
            manualInd.classList.toggle('active', state.currentInput === 'manual');
            sensorInd.classList.toggle('active', state.currentInput === 'sensor');
        }
        
        function isManualActive() {
            return Date.now() - state.manual.lastActivity < CONFIG.manualInputTimeout;
        }
        
        function initFaceTracking() {
            if (typeof Parallax === 'undefined') {
                console.warn('Parallax library not loaded');
                return Promise.reject('Parallax library not loaded');
            }
            
            return Parallax.init(view => {
                state.sensor.x = view.x * CONFIG.inputSensitivity;
                state.sensor.y = -view.y * CONFIG.inputSensitivity;
                state.sensor.available = true;
            }, {
                smoothEye: 0.8,
                smoothDist: 0.2,
                threshold: 0.5 
            });
        }
        
        function initGyroscope() {
            return new Promise((resolve, reject) => {
                if (!window.DeviceOrientationEvent) {
                    reject('No gyroscope');
                    return;
                }
                
                const handler = (e) => {
                    if (e.gamma === null) return;
                    
                    state.sensor.x = Math.max(-2, Math.min(2, (e.gamma / 30) * CONFIG.inputSensitivity));
                    state.sensor.y = Math.max(-2, Math.min(2, ((e.beta - 45) / 30) * CONFIG.inputSensitivity));
                    state.sensor.available = true;
                };
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', handler);
                                resolve();
                            } else {
                                reject('Permission denied');
                            }
                        }).catch(reject);
                } else {
                    window.addEventListener('deviceorientation', handler);
                    resolve();
                }
            });
        }
        
        function initManualInput() {
            document.addEventListener('mousemove', (e) => {
                state.manual.lastActivity = Date.now();
                state.manual.x = (e.clientX / window.innerWidth - 0.5) * 3;
                state.manual.y = -(e.clientY / window.innerHeight - 0.5) * 3;
            });

            let lastX = 0, lastY = 0;
            let offsetX = 0, offsetY = 0;
            const sensitivity = 5.0;
            
            document.addEventListener('touchstart', (e) => {
                state.manual.lastActivity = Date.now();
                const touch = e.touches[0];
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                state.manual.lastActivity = Date.now();
                const touch = e.touches[0];
                const dx = ((touch.clientX - lastX) / window.innerWidth) * sensitivity;
                const dy = ((touch.clientY - lastY) / window.innerHeight) * sensitivity;
                
                offsetX = Math.max(-1.5, Math.min(1.5, offsetX + dx));
                offsetY = Math.max(-1.5, Math.min(1.5, offsetY - dy));
                
                state.manual.x = offsetX;
                state.manual.y = offsetY;
                
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
        }

        // ============================================================
        // MAIN
        // ============================================================
        
        async function init() {
            console.log('Initializing...');
            
            await initThreeJS();
            
            initManualInput();
            
            initFaceTracking()
                .then(() => console.log('Face tracking initialized'))
                .catch((e) => {
                    console.log('Face tracking unavailable:', e);
                    if ('ontouchstart' in window) {
                        initGyroscope()
                            .then(() => console.log('Gyroscope initialized'))
                            .catch((e) => console.log('Gyroscope unavailable:', e));
                    }
                });
            
            function animate() {
                const now = Date.now();
                let targetX = 0, targetY = 0;
                
                const manualActive = isManualActive();
                
                if (manualActive) {
                    targetX = state.manual.x;
                    targetY = state.manual.y;
                    state.currentInput = 'manual';
                } else if (state.sensor.available) {
                    targetX = state.sensor.x;
                    targetY = state.sensor.y;
                    state.currentInput = 'sensor';
                } else {
                    state.currentInput = 'none';
                }
                
                state.viewX += (targetX - state.viewX) * CONFIG.smoothing;
                state.viewY += (targetY - state.viewY) * CONFIG.smoothing;
                
                if (now % 10 < 2) {
                    updateInputIndicators();
                }
                
                renderThreeJS();
                updateTextParallax();
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
