<!DOCTYPE html>
<html>
<head>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas { 
            width: 512px;  /* Default size - will be adjusted when image loads */
            height: 512px;
            display: block;
            border-radius: 20px;
            box-shadow: 
                inset 0 0 50px rgba(0,0,0,0.7),
                0 5px 15px rgba(0,0,0,0.5),
                0 15px 35px rgba(0,0,0,0.3);
            border: 20px solid #333;
            background: #000;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.159.0/three.min.js"></script>
    <script>
        let camera, scene, renderer, material;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(512, 512); // Default size
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    mousePos: { value: new THREE.Vector2(0.5, 0.5) },
                    tDiffuse: { value: null },
                    resolution: { value: new THREE.Vector2(512, 512) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform vec2 mousePos;
                    uniform float time;
                    uniform vec2 resolution;
                    varying vec2 vUv;

                    // Enhanced scanline effect
                    float scanline(vec2 uv) {
                        float scan1 = sin(uv.y * resolution.y * 2.0 - time * 10.0) * 0.08;
                        float scan2 = sin(uv.y * resolution.y * 1.0 - time * 5.0) * 0.04;
                        return 1.0 - scan1 - scan2;
                    }

                    // Stronger CRT curve
                    vec2 curveRemapUV(vec2 uv) {
                        uv = uv * 2.0 - 1.0;
                        vec2 offset = abs(uv.yx) / vec2(3.0, 2.5);
                        uv = uv + uv * offset * offset;
                        uv = uv * 0.5 + 0.5;
                        return uv;
                    }

                    // Enhanced vignette
                    float vignette(vec2 uv) {
                        uv = uv * 2.0 - 1.0;
                        return 1.0 - dot(uv, uv) * 0.4;
                    }

                    void main() {
                        // Apply stronger CRT curve
                        vec2 uv = curveRemapUV(vUv);
                        
                        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                            return;
                        }

                        float distanceFromMouse = length(uv - mousePos);
                        float angle = atan(uv.y - mousePos.y, uv.x - mousePos.x);
                        
                        // Base strength with distance-based intensity
                        float strength = distanceFromMouse * 0.03;
                        float colorIntensity = smoothstep(0.0, 0.5, strength) * 1.5 + 0.8;
                        
                        vec2 redOffset = vec2(cos(angle), sin(angle)) * strength;
                        vec2 greenOffset = vec2(cos(angle + 2.0944), sin(angle + 2.0944)) * strength * 0.8;
                        vec2 blueOffset = vec2(cos(angle + 4.18879), sin(angle + 4.18879)) * strength * 0.6;
                        
                        vec4 redSample = texture2D(tDiffuse, uv + redOffset);
                        vec4 greenSample = texture2D(tDiffuse, uv + greenOffset);
                        vec4 blueSample = texture2D(tDiffuse, uv + blueOffset);
                        
                        // Enhance color separation with distance
                        vec3 color = vec3(
                            redSample.r * colorIntensity,
                            greenSample.g * colorIntensity,
                            blueSample.b * colorIntensity
                        );
                        
                        // Add scanlines
                        color *= scanline(uv);
                        
                        // Add vignette
                        color *= vignette(uv);
                        
                        // Add subtle color bleed
                        float bleed = sin(uv.y * resolution.y * 0.25) * 0.02;
                        color.r += bleed;
                        color.b -= bleed;
                        
                        // Add subtle flicker
                        float flicker = sin(time * 8.0) * 0.03 + 0.97;
                        color *= flicker;

                        gl_FragColor = vec4(color, 1.0);
                    }
                `
            });

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                '/img/flyer1.png',
                (texture) => {
                    material.uniforms.tDiffuse.value = texture;
                    
                    // Set canvas size based on loaded image
                    const width = texture.image.width;
                    const height = texture.image.height;
                    renderer.setSize(width, height);
                    material.uniforms.resolution.value.set(width, height);
                    
                    const imgAspect = width / height;
                    const planeGeometry = new THREE.PlaneGeometry(2 * imgAspect, 2);
                    const plane = new THREE.Mesh(planeGeometry, material);
                    scene.add(plane);
                    
                    renderer.render(scene, camera);
                    
                    // Adjust canvas style
                    const canvas = renderer.domElement;
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                }
            );

            document.addEventListener('mousemove', (event) => {
                const rect = renderer.domElement.getBoundingClientRect();
                const x = (event.clientX - rect.left) / rect.width;
                const y = 1.0 - (event.clientY - rect.top) / rect.height;
                material.uniforms.mousePos.value.set(x, y);
            });
        }

        function animate(time) {
            requestAnimationFrame(animate);
            material.uniforms.time.value = time * 0.001;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>