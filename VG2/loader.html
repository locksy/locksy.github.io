<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Virgo Gabrielle - Loading</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            background: #050505;
            overflow: hidden;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* Image canvas - Middle Layer */
        #depthCanvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1; /* Moved behind prism */
            pointer-events: none; 
        }

        /* Prism shader - Top Layer */
        #prismCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2; /* Moved on top */
            pointer-events: none;
            mix-blend-mode: lighten; /* 'Lighten' is subtle on light images, visible on black */
            opacity: 0.6; /* Balanced visibility */
        }

        /* Loading / Status Indicator */
        .status-display {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
        }

        .loading-text {
            font-size: 12px;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            animation: pulse 2s infinite;
        }

        .input-indicators {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .indicator {
            font-size: 9px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            transition: color 0.3s, opacity 0.3s;
            opacity: 0.5;
        }

        .indicator.active {
            color: #c9a962;
            opacity: 1;
        }

        .indicator::before {
            content: '';
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: currentColor;
            margin-right: 6px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="depthCanvas"></canvas>
    <canvas id="prismCanvas"></canvas>
    
    <div class="status-display">
        <div class="loading-text" id="mainStatus">LOADING</div>
        <div class="input-indicators">
            <div class="indicator" id="ind-manual">Touch/Mouse</div>
            <div class="indicator" id="ind-sensor">Sensor</div>
        </div>
    </div>

    <!-- Face tracking library -->
    <script src="https://cdn.jsdelivr.net/npm/parallax-effect/dist/parallax-effect.min.js"></script>

    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const CONFIG = {
            imagePath: '/loader-img.png',
            depthPath: '/loader-depth.png',
            // Parallax settings
            parallaxStrength: 30,        // Reduced from 60 to prevent breaking the illusion
            smoothing: 0.08,             // Smoothing factor
            inputSensitivity: 2.5,       // Multiplier for Sensor input to compensate for lower parallax
        };

        // ============================================================
        // GLOBAL STATE
        // ============================================================
        const state = {
            // Separated inputs for additive control
            sensor: { x: 0, y: 0, active: false },  // Face or Gyro
            manual: { x: 0, y: 0, active: false },  // Mouse or Touch
            
            // Final View State
            viewX: 0,
            viewY: 0,
            targetX: 0,
            targetY: 0,
        };

        // ============================================================
        // VERTEX SHADER (shared)
        // ============================================================
        const vertexShader = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        // ============================================================
        // DEPTH PARALLAX SHADER
        // ============================================================
        const depthParallaxShader = `
            precision highp float;
            varying vec2 v_texCoord;
            
            uniform sampler2D u_image;
            uniform sampler2D u_depth;
            uniform vec2 u_viewOffset;
            uniform float u_strength;
            
            void main() {
                vec2 uv = v_texCoord;
                
                float depth = texture2D(u_depth, uv).r;
                
                // Parallax offset
                vec2 offset = -u_viewOffset * depth * u_strength;
                vec2 displacedUV = uv + offset;
                
                vec4 color = texture2D(u_image, displacedUV);
                
                // Clean edges
                if (displacedUV.x < 0.0 || displacedUV.x > 1.0 || 
                    displacedUV.y < 0.0 || displacedUV.y > 1.0) {
                    color.a = 0.0;
                }
                
                gl_FragColor = color;
            }
        `;

        // ============================================================
        // PRISM SHADER - Buffer A (Visuals bumped up)
        // ============================================================
        const prismBufferShader = `
            precision highp float;
            varying vec2 v_texCoord;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform sampler2D u_buffer;

            #define R u_resolution

            vec2 tile(vec2 v) {
                return ((fract(v) * 2.0 - 1.0) * sign(fract(0.5 * v) * 2.0 - 1.0)) * 0.5 + 0.5;
            }

            vec4 A(vec2 U) {
                return texture2D(u_buffer, tile(U / R));
            }

            void main() {
                vec2 U = v_texCoord * R;
                
                // Primary light follows input
                vec2 e = u_mouse;
                // High intensity for core
                vec4 Q = vec4(120.0) * exp(-2e2 * length(U - e) / R.y);
                
                // Secondary ambient light
                e = (0.5 + 0.35 * vec2(sin(0.15 * u_time), cos(0.1 * u_time))) * R;
                // High intensity for swirls
                Q += vec4(12.0 + 8.0 * sin(u_time * 0.3), 10.0 - 8.0 * sin(u_time * 0.3), -8.0 * sin(0.2 * u_time), 10.0) 
                     * exp(-10e1 * length(U - e) / R.y);
                
                // Rotation
                float a = 0.02 * u_time;
                float c = cos(a), s = sin(a);
                mat2 m = mat2(c, -s, s, c);
                
                vec3 o = vec3(U - 0.5 * R, 0.0);
                o.xy *= m;
                
                a = 0.08 * sin(0.08 * u_time);
                c = cos(a); s = sin(a);
                m = mat2(c, -s, s, c);
                o.yz *= m;
                
                // Layer accumulation
                for (float i = -15.0; i < 15.0; i++) {
                    vec2 u = (1.2 + 0.2 * sin(0.15 * u_time)) * -o.xy + 0.5 * R + 0.004 * R.y * i;
                    Q += 0.1 * A(u) * exp(-1.2 * abs(2.0 - 0.2 * i - vec4(1.0, 2.0, 3.0, 4.0)));
                }
                
                gl_FragColor = Q;
            }
        `;

        // ============================================================
        // PRISM SHADER - Image pass
        // ============================================================
        const prismImageShader = `
            precision highp float;
            varying vec2 v_texCoord;
            uniform vec2 u_resolution;
            uniform sampler2D u_buffer;

            #define R u_resolution

            void main() {
                vec2 U = v_texCoord * R;
                vec4 a = texture2D(u_buffer, U / R);
                
                vec4 Q = vec4(0.0);
                Q += a.x * exp(-abs(0.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                Q += a.y * exp(-abs(1.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                Q += a.z * exp(-abs(2.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                Q += a.w * exp(-abs(3.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                
                gl_FragColor = Q;
            }
        `;

        // ============================================================
        // WEBGL UTILITIES
        // ============================================================
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load ${src}`));
                img.src = src;
            });
        }

        // ============================================================
        // RENDERERS
        // ============================================================
        class DepthParallaxRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl', { 
                    antialias: true, 
                    alpha: true,
                    premultipliedAlpha: false 
                });
                this.ready = false;
            }
            
            async init(imageSrc, depthSrc) {
                const gl = this.gl;
                if (!gl) return;
                
                const [image, depth] = await Promise.all([
                    loadImage(imageSrc),
                    loadImage(depthSrc)
                ]);
                
                // Match canvas to image natural size
                this.canvas.width = image.naturalWidth;
                this.canvas.height = image.naturalHeight;
                this.canvas.style.width = image.naturalWidth + 'px';
                this.canvas.style.height = image.naturalHeight + 'px';
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                this.program = createProgram(gl, vertexShader, depthParallaxShader);
                
                // Full screen quad geometry
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const texCoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]); // Flip Y
                
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                const texBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                
                this.imageTexture = this.createTexture(image);
                this.depthTexture = this.createTexture(depth);
                
                gl.useProgram(this.program);
                this.uniforms = {
                    image: gl.getUniformLocation(this.program, 'u_image'),
                    depth: gl.getUniformLocation(this.program, 'u_depth'),
                    viewOffset: gl.getUniformLocation(this.program, 'u_viewOffset'),
                    strength: gl.getUniformLocation(this.program, 'u_strength'),
                    posLoc: gl.getAttribLocation(this.program, 'a_position'),
                    texLoc: gl.getAttribLocation(this.program, 'a_texCoord')
                };

                // Bind attributes once since they don't change
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.enableVertexAttribArray(this.uniforms.posLoc);
                gl.vertexAttribPointer(this.uniforms.posLoc, 2, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
                gl.enableVertexAttribArray(this.uniforms.texLoc);
                gl.vertexAttribPointer(this.uniforms.texLoc, 2, gl.FLOAT, false, 0, 0);
                
                this.ready = true;
            }
            
            createTexture(image) {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
            }
            
            render() {
                if (!this.ready) return;
                const gl = this.gl;
                
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(this.program);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                gl.uniform1i(this.uniforms.image, 0);
                
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
                gl.uniform1i(this.uniforms.depth, 1);
                
                // Convert pixel strength to UV space
                const uvStrength = CONFIG.parallaxStrength / this.canvas.width;
                gl.uniform2f(this.uniforms.viewOffset, state.viewX, state.viewY);
                gl.uniform1f(this.uniforms.strength, uvStrength);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        class PrismRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl', { antialias: false, alpha: true });
                this.startTime = Date.now();
                this.fbos = [];
                this.currentBuffer = 0;
                this.ready = false;
            }
            
            init() {
                const gl = this.gl;
                if (!gl) return;
                this.resize();
                
                this.bufferProgram = createProgram(gl, vertexShader, prismBufferShader);
                this.imageProgram = createProgram(gl, vertexShader, prismImageShader);
                
                this.createGeometry();
                this.setupUniforms();
                this.createFramebuffers();
                
                window.addEventListener('resize', () => {
                    this.resize();
                    this.createFramebuffers();
                });
                
                this.ready = true;
            }
            
            resize() {
                const dpr = Math.min(window.devicePixelRatio, 2);
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            createGeometry() {
                const gl = this.gl;
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const texCoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
                
                this.posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                this.texBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
            }
            
            setupUniforms() {
                const gl = this.gl;
                this.bufferUniforms = {
                    time: gl.getUniformLocation(this.bufferProgram, 'u_time'),
                    resolution: gl.getUniformLocation(this.bufferProgram, 'u_resolution'),
                    mouse: gl.getUniformLocation(this.bufferProgram, 'u_mouse'),
                    buffer: gl.getUniformLocation(this.bufferProgram, 'u_buffer'),
                };
                this.imageUniforms = {
                    resolution: gl.getUniformLocation(this.imageProgram, 'u_resolution'),
                    buffer: gl.getUniformLocation(this.imageProgram, 'u_buffer'),
                };
            }
            
            createFramebuffers() {
                const gl = this.gl;
                this.fbos.forEach(fbo => {
                    if (fbo.texture) gl.deleteTexture(fbo.texture);
                    if (fbo.framebuffer) gl.deleteFramebuffer(fbo.framebuffer);
                });
                this.fbos = [];
                for (let i = 0; i < 2; i++) {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    
                    const framebuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    
                    this.fbos.push({ texture, framebuffer });
                }
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            
            setupAttributes(program) {
                const gl = this.gl;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                const posLoc = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
                const texLoc = gl.getAttribLocation(program, 'a_texCoord');
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
            }
            
            render() {
                if (!this.ready) return;
                const gl = this.gl;
                const time = (Date.now() - this.startTime) / 1000;
                
                // Mouse for prism follows combined view state
                // Center + (Direction * Amplitude)
                const mouseX = (state.viewX * 0.5 + 0.5) * this.canvas.width;
                const mouseY = (-state.viewY * 0.5 + 0.5) * this.canvas.height;
                
                const readBuffer = this.fbos[this.currentBuffer];
                const writeBuffer = this.fbos[1 - this.currentBuffer];
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, writeBuffer.framebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.bufferProgram);
                this.setupAttributes(this.bufferProgram);
                
                gl.uniform1f(this.bufferUniforms.time, time);
                gl.uniform2f(this.bufferUniforms.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.bufferUniforms.mouse, mouseX, mouseY);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readBuffer.texture);
                gl.uniform1i(this.bufferUniforms.buffer, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                this.currentBuffer = 1 - this.currentBuffer;
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.imageProgram);
                this.setupAttributes(this.imageProgram);
                gl.uniform2f(this.imageUniforms.resolution, this.canvas.width, this.canvas.height);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, writeBuffer.texture);
                gl.uniform1i(this.imageUniforms.buffer, 0);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // ============================================================
        // INPUT HANDLERS (ADDITIVE LOGIC)
        // ============================================================
        
        // 1. Face Tracking (Sensor)
        function initFaceTracking() {
            if (typeof Parallax === 'undefined') return Promise.reject('Parallax library not loaded');
            
            return Parallax.init(view => {
                // Apply Sensitivity Multiplier
                state.sensor.x = view.x * CONFIG.inputSensitivity;
                state.sensor.y = -view.y * CONFIG.inputSensitivity;
                
                if (!state.sensor.active) {
                    state.sensor.active = true;
                    document.getElementById('ind-sensor').classList.add('active');
                }
            }, {
                smoothEye: 0.85,
                smoothDist: 0.3,
                threshold: 0.75
            });
        }
        
        // 2. Gyroscope (Sensor)
        function initGyroscope() {
            return new Promise((resolve, reject) => {
                if (!window.DeviceOrientationEvent) {
                    reject('No gyroscope');
                    return;
                }
                
                const handler = (e) => {
                    if (e.gamma === null) return;
                    
                    // Apply Sensitivity Multiplier to Gyro
                    // Clamp to prevent extreme values from user spinning device
                    state.sensor.x = Math.max(-2, Math.min(2, (e.gamma / 30) * CONFIG.inputSensitivity));
                    state.sensor.y = Math.max(-2, Math.min(2, ((e.beta - 45) / 30) * CONFIG.inputSensitivity));
                    
                    if (!state.sensor.active) {
                        state.sensor.active = true;
                        document.getElementById('ind-sensor').classList.add('active');
                    }
                };
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', handler);
                                resolve();
                            } else {
                                reject('Permission denied');
                            }
                        }).catch(reject);
                } else {
                    window.addEventListener('deviceorientation', handler);
                    resolve();
                }
            });
        }
        
        // 3. Touch (Manual)
        function initTouch() {
            let lastX = 0, lastY = 0;
            let offsetX = 0, offsetY = 0;
            
            document.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                lastX = touch.clientX;
                lastY = touch.clientY;
                
                if (!state.manual.active) {
                    state.manual.active = true;
                    document.getElementById('ind-manual').classList.add('active');
                }
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                const dx = (touch.clientX - lastX) / window.innerWidth * 4;
                const dy = (touch.clientY - lastY) / window.innerHeight * 4;
                
                offsetX = Math.max(-1, Math.min(1, offsetX + dx));
                offsetY = Math.max(-1, Math.min(1, offsetY - dy));
                
                state.manual.x = offsetX;
                state.manual.y = offsetY;
                
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
        }
        
        // 4. Mouse (Manual)
        function initMouse() {
            document.addEventListener('mousemove', (e) => {
                state.manual.x = (e.clientX / window.innerWidth - 0.5) * 2;
                state.manual.y = -(e.clientY / window.innerHeight - 0.5) * 2;
                
                if (!state.manual.active) {
                    state.manual.active = true;
                    document.getElementById('ind-manual').classList.add('active');
                }
            });
        }

        // ============================================================
        // PRELOADER LOGIC
        // ============================================================
        
        const ASSETS_TO_LOAD = [
            'index-gemini1.html',
            ...Array.from({length: 10}, (_, i) => `${i + 1}.JPG`) // 1.JPG to 10.JPG
        ];

        async function preloadAssets() {
            console.log('Starting preload...');
            const promises = ASSETS_TO_LOAD.map(url => {
                return new Promise((resolve, reject) => {
                    
                    if (url.endsWith('.html')) {
                        // Preload HTML via fetch
                        fetch(url).then(r => r.text()).then(resolve).catch(resolve);
                    } else {
                        // Preload Images
                        const img = new Image();
                        img.src = url;
                        img.onload = resolve;
                        img.onerror = resolve; // Continue even on error
                    }
                });
            });

            await Promise.all(promises);
            console.log('All assets preloaded.');
            document.getElementById('mainStatus').innerText = 'READY';
            
            // Optional: Auto redirect when ready?
            // window.location.href = 'index-gemini1.html';
        }

        // ============================================================
        // MAIN
        // ============================================================
        let depthRenderer, prismRenderer;
        
        async function init() {
            // Initialize renderers
            depthRenderer = new DepthParallaxRenderer(document.getElementById('depthCanvas'));
            prismRenderer = new PrismRenderer(document.getElementById('prismCanvas'));
            
            try {
                await depthRenderer.init(CONFIG.imagePath, CONFIG.depthPath);
                prismRenderer.init();
            } catch (e) {
                console.error('Failed to initialize:', e);
                return;
            }
            
            // Start render loop
            function render() {
                // ADDITIVE LOGIC: Combine Sensor + Manual input
                // This allows mouse to "push" the view even if face tracking is active
                const combinedX = Math.max(-1.5, Math.min(1.5, state.sensor.x + state.manual.x));
                const combinedY = Math.max(-1.5, Math.min(1.5, state.sensor.y + state.manual.y));

                state.targetX = combinedX;
                state.targetY = combinedY;

                // Smoothing
                state.viewX += (state.targetX - state.viewX) * CONFIG.smoothing;
                state.viewY += (state.targetY - state.viewY) * CONFIG.smoothing;
                
                depthRenderer.render();
                prismRenderer.render();
                
                requestAnimationFrame(render);
            }
            render();
            
            // Start Inputs - Initialize ALL of them (not cascading)
            // This ensures Mouse/Touch always works, and Sensor kicks in if available
            initMouse();
            if ('ontouchstart' in window) initTouch();
            
            initFaceTracking().catch(() => {
                // If face tracking fails or isn't permissioned yet, try gyro
                if ('ontouchstart' in window) initGyroscope().catch(e => console.log('Gyro unavailable'));
            });

            // =========================================
            // PRELOADER TRIGGER
            // Uncomment the line below to enable preloading
            // =========================================
            // preloadAssets();
        }
        
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
