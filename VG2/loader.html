<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Virgo Gabrielle - Loader</title>
    
    <style>
        @font-face {
            font-family: 'Hyena';
            src: url('./hyena.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            background: #000000;
            overflow: hidden;
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        /* Image canvas */
        #depthCanvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            max-width: 100vw;
            max-height: 100vh;
            width: auto;
            height: auto;
            object-fit: contain;
            z-index: 1; 
            pointer-events: none; 
        }

        /* Title Container */
        .title-container {
            position: fixed;
            bottom: 15%;
            left: 0;
            width: 100%;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
        }

        .title-text {
            font-family: 'Hyena', Arial Black, sans-serif;
            font-size: clamp(60px, 18vw, 220px);
            font-weight: 900;
            letter-spacing: -0.02em;
            text-transform: uppercase;
            color: rgba(255, 8, 0, 0.19);
            -webkit-text-stroke: 1px rgba(28, 51, 255, 1.2);
            text-stroke: 1px rgba(151, 23, 23, 01.2);
            paint-order: stroke fill;
            mix-blend-mode: color-dodge;
            will-change: transform;
            backdrop-filter: blur(20px) saturate(1.4);
            -webkit-backdrop-filter: blur(20px) saturate(1.4);
            text-shadow: 
                0 0 40px rgba(255, 255, 255, 0.1),
                0 0 80px rgba(255, 255, 255, 0.05);
        }

        /* Loading / Status Indicator */
        .status-display {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            width: 100%;
            pointer-events: none;
        }

        .loading-text {
            font-size: 12px;
            letter-spacing: 0.4em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 8px;
            animation: pulse 2s infinite;
        }

        .input-indicators {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .indicator {
            font-size: 9px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            transition: color 0.3s, opacity 0.3s;
            opacity: 0.5;
        }

        .indicator.active {
            color: #c9a962;
            opacity: 1;
        }

        .indicator::before {
            content: '';
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: currentColor;
            margin-right: 6px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="depthCanvas"></canvas>
    
    <!-- Title -->
    <div class="title-container">
        <div class="title-text" id="titleText">VIRGO</div>
    </div>
    
    <div class="status-display">
        <div class="loading-text" id="mainStatus">LOADING</div>
        <div class="input-indicators">
            <div class="indicator" id="ind-manual">Touch/Mouse</div>
            <div class="indicator" id="ind-sensor">Sensor</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/parallax-effect/dist/parallax-effect.min.js"></script>

    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const CONFIG = {
            imagePath: './new-img.png',
            depthPath: './new-depth.png',
            
            parallaxStrength: 25,
            inputSensitivity: 10,
            smoothing: 0.25,
            
            chromaticAberration: 0.015,
            noiseAmount: 0.03,
            
            zoomLevel: 0.85,
            
            // Title parallax (very subtle)
            titleParallaxStrength: 2,
            
            // Input timeout (ms)
            manualInputTimeout: 2000,
        };

        // ============================================================
        // GLOBAL STATE
        // ============================================================
        const state = {
            sensor: { x: 0, y: 0, available: false },
            manual: { x: 0, y: 0, lastActivity: 0 },
            viewX: 0, 
            viewY: 0, 
            currentInput: 'none',
        };

        // ============================================================
        // SHADERS
        // ============================================================
        const vertexShader = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        const depthParallaxShader = `
            precision highp float;
            varying vec2 v_texCoord;
            
            uniform sampler2D u_image;
            uniform sampler2D u_depth;
            uniform vec2 u_viewOffset;
            uniform float u_strength;
            uniform float u_zoom;
            uniform float u_ca;          
            uniform float u_noise;       
            uniform float u_time;
            uniform vec2 u_resolution;
            
            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }
            
            vec4 sampleDisplaced(vec2 uv, vec2 offset) {
                float depth = texture2D(u_depth, uv).r;
                vec2 baseOffset = -u_viewOffset * depth * u_strength;
                
                float distortion = length(u_viewOffset) * 2.0; 
                float dynamicCA = u_ca * (1.0 + distortion);

                vec2 offsetR = baseOffset + u_viewOffset * dynamicCA * depth;
                vec2 offsetB = baseOffset - u_viewOffset * dynamicCA * depth;

                float r = texture2D(u_image, uv + offsetR).r;
                float g = texture2D(u_image, uv + baseOffset).g;
                float b = texture2D(u_image, uv + offsetB).b;

                vec4 color = vec4(r, g, b, 1.0);

                if (uv.x + offsetR.x < 0.0 || uv.x + offsetR.x > 1.0 || 
                    uv.y + offsetR.y < 0.0 || uv.y + offsetR.y > 1.0 ||
                    uv.x + offsetB.x < 0.0 || uv.x + offsetB.x > 1.0 || 
                    uv.y + offsetB.y < 0.0 || uv.y + offsetB.y > 1.0) {
                    color.a = 0.0;
                }

                return color;
            }

            void main() {
                float margin = (1.0 - u_zoom) * 0.5;
                vec2 uv = v_texCoord * u_zoom + margin;
                
                vec4 finalColor = sampleDisplaced(uv, u_viewOffset);
                
                float noise = hash(floor(v_texCoord * u_resolution * 0.5) + u_time * 0.1) * 2.0 - 1.0;
                finalColor.rgb += noise * u_noise * finalColor.a;

                gl_FragColor = finalColor;
            }
        `;

        // ============================================================
        // UTILS
        // ============================================================
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const program = gl.createProgram();
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            if (!vs || !fs) return null;
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "anonymous"; 
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load ${src}`));
                img.src = src;
            });
        }

        // ============================================================
        // DEPTH RENDERER
        // ============================================================
        class DepthParallaxRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl', { 
                    antialias: true, 
                    alpha: true,
                    premultipliedAlpha: false 
                });
                this.ready = false;
            }
            
            async init(imageSrc, depthSrc) {
                const gl = this.gl;
                if (!gl) return;
                
                try {
                    const [image, depth] = await Promise.all([
                        loadImage(imageSrc),
                        loadImage(depthSrc)
                    ]);
                    
                    this.canvas.width = image.naturalWidth;
                    this.canvas.height = image.naturalHeight;
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.program = createProgram(gl, vertexShader, depthParallaxShader);
                    if (!this.program) throw new Error("Shader init failed");
                    
                    const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                    const texCoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
                    
                    const posBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                    
                    const texBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                    
                    this.imageTexture = this.createTexture(image);
                    this.depthTexture = this.createTexture(depth);
                    
                    gl.useProgram(this.program);
                    this.uniforms = {
                        image: gl.getUniformLocation(this.program, 'u_image'),
                        depth: gl.getUniformLocation(this.program, 'u_depth'),
                        viewOffset: gl.getUniformLocation(this.program, 'u_viewOffset'),
                        strength: gl.getUniformLocation(this.program, 'u_strength'),
                        zoom: gl.getUniformLocation(this.program, 'u_zoom'),
                        ca: gl.getUniformLocation(this.program, 'u_ca'),
                        noise: gl.getUniformLocation(this.program, 'u_noise'),
                        time: gl.getUniformLocation(this.program, 'u_time'),
                        resolution: gl.getUniformLocation(this.program, 'u_resolution'),
                        posLoc: gl.getAttribLocation(this.program, 'a_position'),
                        texLoc: gl.getAttribLocation(this.program, 'a_texCoord')
                    };

                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                    gl.enableVertexAttribArray(this.uniforms.posLoc);
                    gl.vertexAttribPointer(this.uniforms.posLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
                    gl.enableVertexAttribArray(this.uniforms.texLoc);
                    gl.vertexAttribPointer(this.uniforms.texLoc, 2, gl.FLOAT, false, 0, 0);
                    
                    this.startTime = Date.now();
                    this.ready = true;
                    document.getElementById('mainStatus').innerText = 'READY';
                } catch(e) {
                    console.error("Depth init failed", e);
                    document.getElementById('mainStatus').innerText = 'ERROR';
                }
            }
            
            createTexture(image) {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
            }
            
            render() {
                if (!this.ready) return;
                const gl = this.gl;
                const time = (Date.now() - this.startTime) / 1000;
                
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(this.program);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                gl.uniform1i(this.uniforms.image, 0);
                
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
                gl.uniform1i(this.uniforms.depth, 1);
                
                const uvStrength = CONFIG.parallaxStrength / this.canvas.width;
                
                gl.uniform2f(this.uniforms.viewOffset, state.viewX, state.viewY);
                gl.uniform1f(this.uniforms.strength, uvStrength);
                gl.uniform1f(this.uniforms.zoom, CONFIG.zoomLevel);
                gl.uniform1f(this.uniforms.ca, CONFIG.chromaticAberration);
                gl.uniform1f(this.uniforms.noise, CONFIG.noiseAmount);
                gl.uniform1f(this.uniforms.time, time);
                gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // ============================================================
        // INPUT HANDLERS
        // ============================================================
        
        function updateInputIndicators() {
            const manualInd = document.getElementById('ind-manual');
            const sensorInd = document.getElementById('ind-sensor');
            
            manualInd.classList.toggle('active', state.currentInput === 'manual');
            sensorInd.classList.toggle('active', state.currentInput === 'sensor');
        }
        
        function isManualActive() {
            return Date.now() - state.manual.lastActivity < CONFIG.manualInputTimeout;
        }
        
        function initFaceTracking() {
            if (typeof Parallax === 'undefined') {
                console.warn('Parallax library not loaded');
                return Promise.reject('Parallax library not loaded');
            }
            
            return Parallax.init(view => {
                state.sensor.x = view.x * CONFIG.inputSensitivity;
                state.sensor.y = -view.y * CONFIG.inputSensitivity;
                state.sensor.available = true;
            }, {
                smoothEye: 0.8,
                smoothDist: 0.2,
                threshold: 0.5 
            });
        }
        
        function initGyroscope() {
            return new Promise((resolve, reject) => {
                if (!window.DeviceOrientationEvent) {
                    reject('No gyroscope');
                    return;
                }
                
                const handler = (e) => {
                    if (e.gamma === null) return;
                    
                    state.sensor.x = Math.max(-2, Math.min(2, (e.gamma / 30) * CONFIG.inputSensitivity));
                    state.sensor.y = Math.max(-2, Math.min(2, ((e.beta - 45) / 30) * CONFIG.inputSensitivity));
                    state.sensor.available = true;
                };
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', handler);
                                resolve();
                            } else {
                                reject('Permission denied');
                            }
                        }).catch(reject);
                } else {
                    window.addEventListener('deviceorientation', handler);
                    resolve();
                }
            });
        }
        
        function initManualInput() {
            console.log('Initializing manual input handlers');
            
            // Mouse Input
            document.addEventListener('mousemove', (e) => {
                state.manual.lastActivity = Date.now();
                state.manual.x = (e.clientX / window.innerWidth - 0.5) * 3;
                state.manual.y = -(e.clientY / window.innerHeight - 0.5) * 3;
            });

            // Touch Input
            let lastX = 0, lastY = 0;
            let offsetX = 0, offsetY = 0;
            const sensitivity = 5.0;
            
            document.addEventListener('touchstart', (e) => {
                state.manual.lastActivity = Date.now();
                const touch = e.touches[0];
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                state.manual.lastActivity = Date.now();
                const touch = e.touches[0];
                const dx = ((touch.clientX - lastX) / window.innerWidth) * sensitivity;
                const dy = ((touch.clientY - lastY) / window.innerHeight) * sensitivity;
                
                offsetX = Math.max(-1.5, Math.min(1.5, offsetX + dx));
                offsetY = Math.max(-1.5, Math.min(1.5, offsetY - dy));
                
                state.manual.x = offsetX;
                state.manual.y = offsetY;
                
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
        }

        // ============================================================
        // TITLE PARALLAX
        // ============================================================
        function updateTitleParallax() {
            const titleEl = document.getElementById('titleText');
            const offsetX = state.viewX * CONFIG.titleParallaxStrength;
            const offsetY = -state.viewY * CONFIG.titleParallaxStrength;
            titleEl.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
        }

        // ============================================================
        // MAIN
        // ============================================================
        let depthRenderer;
        
        async function init() {
            console.log('Initializing...');
            
            depthRenderer = new DepthParallaxRenderer(document.getElementById('depthCanvas'));
            
            try {
                await depthRenderer.init(CONFIG.imagePath, CONFIG.depthPath);
                console.log('Depth renderer initialized');
            } catch (e) {
                console.error('Failed to initialize renderer:', e);
            }
            
            // Wait for font
            try {
                await document.fonts.load('900 100px Hyena');
                console.log('Font loaded');
            } catch (e) {
                console.warn('Font load failed, using fallback');
            }
            
            // Initialize inputs
            initManualInput();
            
            initFaceTracking()
                .then(() => console.log('Face tracking initialized'))
                .catch((e) => {
                    console.log('Face tracking unavailable:', e);
                    if ('ontouchstart' in window) {
                        initGyroscope()
                            .then(() => console.log('Gyroscope initialized'))
                            .catch((e) => console.log('Gyroscope unavailable:', e));
                    }
                });
            
            function render() {
                const now = Date.now();
                let targetX = 0, targetY = 0;
                
                // Determine which input to use
                const manualActive = isManualActive();
                
                if (manualActive) {
                    targetX = state.manual.x;
                    targetY = state.manual.y;
                    state.currentInput = 'manual';
                } else if (state.sensor.available) {
                    targetX = state.sensor.x;
                    targetY = state.sensor.y;
                    state.currentInput = 'sensor';
                } else {
                    state.currentInput = 'none';
                }
                
                // Smooth interpolation
                state.viewX += (targetX - state.viewX) * CONFIG.smoothing;
                state.viewY += (targetY - state.viewY) * CONFIG.smoothing;
                
                // Update indicators (throttled)
                if (now % 10 < 2) {
                    updateInputIndicators();
                }
                
                // Render
                depthRenderer.render();
                updateTitleParallax();
                
                requestAnimationFrame(render);
            }
            
            render();
        }
        
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
