<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Virgo Gabrielle - Loading</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            background: #050505;
            overflow: hidden;
            touch-action: none;
        }

        /* Image canvas - actual size, centered horizontally, flush top */
        #depthCanvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1;
        }

        /* Prism shader - above the image */
        #prismCanvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
            mix-blend-mode: screen;
            opacity: 0.6;
        }

        /* Input mode indicator */
        .input-mode {
            position: fixed;
            top: 20px;
            right: 20px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 10px;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.3);
            z-index: 100;
        }

        .input-mode::before {
            content: '';
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #c9a962;
            margin-right: 8px;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <canvas id="depthCanvas"></canvas>
    <canvas id="prismCanvas"></canvas>
    <div class="input-mode" id="inputMode">Initializing</div>

    <!-- Face tracking library -->
    <script src="https://cdn.jsdelivr.net/npm/parallax-effect/dist/parallax-effect.min.js"></script>

    <script>
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const CONFIG = {
            imagePath: '/loader-img.png',
            depthPath: '/loader-depth.png',
            // Parallax settings
            parallaxStrength: 25,        // How many pixels max shift
            smoothing: 0.1,              // Lower = smoother (0.05-0.2)
        };

        // ============================================================
        // GLOBAL STATE
        // ============================================================
        const state = {
            inputMode: 'none',
            viewX: 0,                    // Current smoothed value (-1 to 1)
            viewY: 0,
            targetX: 0,                  // Target value from input
            targetY: 0,
        };

        // ============================================================
        // VERTEX SHADER (shared)
        // ============================================================
        const vertexShader = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_texCoord = a_texCoord;
            }
        `;

        // ============================================================
        // DEPTH PARALLAX SHADER
        // Simple and correct UV-based displacement
        // ============================================================
        const depthParallaxShader = `
            precision highp float;
            varying vec2 v_texCoord;
            
            uniform sampler2D u_image;
            uniform sampler2D u_depth;
            uniform vec2 u_viewOffset;      // -1 to 1 range from input
            uniform float u_strength;       // Parallax strength in UV space
            
            void main() {
                vec2 uv = v_texCoord;
                
                // Sample depth (assuming white = close, black = far)
                float depth = texture2D(u_depth, uv).r;
                
                // Calculate offset: closer objects (higher depth) move more
                // Offset is opposite to view direction for natural parallax
                vec2 offset = -u_viewOffset * depth * u_strength;
                
                // Apply offset
                vec2 displacedUV = uv + offset;
                
                // Sample the image at displaced position
                vec4 color = texture2D(u_image, displacedUV);
                
                // If UV is out of bounds, show transparent (or could clamp)
                if (displacedUV.x < 0.0 || displacedUV.x > 1.0 || 
                    displacedUV.y < 0.0 || displacedUV.y > 1.0) {
                    color.a = 0.0;
                }
                
                gl_FragColor = color;
            }
        `;

        // ============================================================
        // PRISM SHADER - Buffer A
        // ============================================================
        const prismBufferShader = `
            precision highp float;
            varying vec2 v_texCoord;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform sampler2D u_buffer;

            #define R u_resolution

            vec2 tile(vec2 v) {
                return ((fract(v) * 2.0 - 1.0) * sign(fract(0.5 * v) * 2.0 - 1.0)) * 0.5 + 0.5;
            }

            vec4 A(vec2 U) {
                return texture2D(u_buffer, tile(U / R));
            }

            void main() {
                vec2 U = v_texCoord * R;
                
                // Primary light follows input
                vec2 e = u_mouse;
                vec4 Q = vec4(80.0) * exp(-2e2 * length(U - e) / R.y);
                
                // Secondary ambient light
                e = (0.5 + 0.35 * vec2(sin(0.15 * u_time), cos(0.1 * u_time))) * R;
                Q += vec4(8.0 + 6.0 * sin(u_time * 0.3), 8.0 - 6.0 * sin(u_time * 0.3), -6.0 * sin(0.2 * u_time), 8.0) 
                     * exp(-10e1 * length(U - e) / R.y);
                
                // Rotation
                float a = 0.02 * u_time;
                float c = cos(a), s = sin(a);
                mat2 m = mat2(c, -s, s, c);
                
                vec3 o = vec3(U - 0.5 * R, 0.0);
                o.xy *= m;
                
                a = 0.08 * sin(0.08 * u_time);
                c = cos(a); s = sin(a);
                m = mat2(c, -s, s, c);
                o.yz *= m;
                
                // Layer accumulation
                for (float i = -15.0; i < 15.0; i++) {
                    vec2 u = (1.2 + 0.2 * sin(0.15 * u_time)) * -o.xy + 0.5 * R + 0.004 * R.y * i;
                    Q += 0.1 * A(u) * exp(-1.2 * abs(2.0 - 0.2 * i - vec4(1.0, 2.0, 3.0, 4.0)));
                }
                
                gl_FragColor = Q;
            }
        `;

        // ============================================================
        // PRISM SHADER - Image pass
        // ============================================================
        const prismImageShader = `
            precision highp float;
            varying vec2 v_texCoord;
            uniform vec2 u_resolution;
            uniform sampler2D u_buffer;

            #define R u_resolution

            void main() {
                vec2 U = v_texCoord * R;
                vec4 a = texture2D(u_buffer, U / R);
                
                vec4 Q = vec4(0.0);
                Q += a.x * exp(-abs(0.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                Q += a.y * exp(-abs(1.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                Q += a.z * exp(-abs(2.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                Q += a.w * exp(-abs(3.5 - vec4(1.0, 2.0, 3.0, 4.0)));
                
                gl_FragColor = Q;
            }
        `;

        // ============================================================
        // WEBGL UTILITIES
        // ============================================================
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error(`Failed to load ${src}`));
                img.src = src;
            });
        }

        // ============================================================
        // DEPTH PARALLAX RENDERER
        // Renders at actual image size
        // ============================================================
        class DepthParallaxRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl', { 
                    antialias: true, 
                    alpha: true,
                    premultipliedAlpha: false 
                });
                this.program = null;
                this.uniforms = {};
                this.imageTexture = null;
                this.depthTexture = null;
                this.ready = false;
            }
            
            async init(imageSrc, depthSrc) {
                const gl = this.gl;
                if (!gl) return;
                
                // Load images
                const [image, depth] = await Promise.all([
                    loadImage(imageSrc),
                    loadImage(depthSrc)
                ]);
                
                // Set canvas to actual image size
                this.canvas.width = image.naturalWidth;
                this.canvas.height = image.naturalHeight;
                this.canvas.style.width = image.naturalWidth + 'px';
                this.canvas.style.height = image.naturalHeight + 'px';
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Create program
                this.program = createProgram(gl, vertexShader, depthParallaxShader);
                
                // Create geometry (full screen quad)
                this.createGeometry();
                
                // Create textures
                this.imageTexture = this.createTexture(image);
                this.depthTexture = this.createTexture(depth);
                
                // Get uniform locations
                gl.useProgram(this.program);
                this.uniforms = {
                    image: gl.getUniformLocation(this.program, 'u_image'),
                    depth: gl.getUniformLocation(this.program, 'u_depth'),
                    viewOffset: gl.getUniformLocation(this.program, 'u_viewOffset'),
                    strength: gl.getUniformLocation(this.program, 'u_strength'),
                };
                
                this.ready = true;
                console.log(`Image loaded: ${image.naturalWidth}x${image.naturalHeight}`);
            }
            
            createGeometry() {
                const gl = this.gl;
                
                // Positions (clip space quad)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                // Tex coords (flip Y for proper orientation)
                const texCoords = new Float32Array([
                    0, 1,
                    1, 1,
                    0, 0,
                    1, 0
                ]);
                
                // Position buffer
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                const posLoc = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                // Tex coord buffer
                const texBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                const texLoc = gl.getAttribLocation(this.program, 'a_texCoord');
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
            }
            
            createTexture(image) {
                const gl = this.gl;
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return texture;
            }
            
            render() {
                if (!this.ready) return;
                
                const gl = this.gl;
                
                // Clear with transparency
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.useProgram(this.program);
                
                // Bind textures
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.imageTexture);
                gl.uniform1i(this.uniforms.image, 0);
                
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, this.depthTexture);
                gl.uniform1i(this.uniforms.depth, 1);
                
                // Set uniforms
                // Convert pixel strength to UV space (0-1 range)
                const uvStrength = CONFIG.parallaxStrength / this.canvas.width;
                gl.uniform2f(this.uniforms.viewOffset, state.viewX, state.viewY);
                gl.uniform1f(this.uniforms.strength, uvStrength);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // ============================================================
        // PRISM RENDERER
        // ============================================================
        class PrismRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl', { antialias: false, alpha: true });
                this.startTime = Date.now();
                this.fbos = [];
                this.currentBuffer = 0;
                this.ready = false;
            }
            
            init() {
                const gl = this.gl;
                if (!gl) return;
                
                this.resize();
                
                this.bufferProgram = createProgram(gl, vertexShader, prismBufferShader);
                this.imageProgram = createProgram(gl, vertexShader, prismImageShader);
                
                this.createGeometry();
                this.setupUniforms();
                this.createFramebuffers();
                
                window.addEventListener('resize', () => {
                    this.resize();
                    this.createFramebuffers();
                });
                
                this.ready = true;
            }
            
            resize() {
                const dpr = Math.min(window.devicePixelRatio, 2);
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }
            
            createGeometry() {
                const gl = this.gl;
                
                const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                const texCoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
                
                this.posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                this.texBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
            }
            
            setupUniforms() {
                const gl = this.gl;
                this.bufferUniforms = {
                    time: gl.getUniformLocation(this.bufferProgram, 'u_time'),
                    resolution: gl.getUniformLocation(this.bufferProgram, 'u_resolution'),
                    mouse: gl.getUniformLocation(this.bufferProgram, 'u_mouse'),
                    buffer: gl.getUniformLocation(this.bufferProgram, 'u_buffer'),
                };
                this.imageUniforms = {
                    resolution: gl.getUniformLocation(this.imageProgram, 'u_resolution'),
                    buffer: gl.getUniformLocation(this.imageProgram, 'u_buffer'),
                };
            }
            
            createFramebuffers() {
                const gl = this.gl;
                
                this.fbos.forEach(fbo => {
                    if (fbo.texture) gl.deleteTexture(fbo.texture);
                    if (fbo.framebuffer) gl.deleteFramebuffer(fbo.framebuffer);
                });
                this.fbos = [];
                
                for (let i = 0; i < 2; i++) {
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    
                    const framebuffer = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    
                    this.fbos.push({ texture, framebuffer });
                }
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            
            setupAttributes(program) {
                const gl = this.gl;
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
                const posLoc = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.texBuffer);
                const texLoc = gl.getAttribLocation(program, 'a_texCoord');
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
            }
            
            render() {
                if (!this.ready) return;
                
                const gl = this.gl;
                const time = (Date.now() - this.startTime) / 1000;
                
                // Mouse position for prism follows view state
                const mouseX = (state.viewX * 0.5 + 0.5) * this.canvas.width;
                const mouseY = (-state.viewY * 0.5 + 0.5) * this.canvas.height;
                
                // Pass 1: Buffer
                const readBuffer = this.fbos[this.currentBuffer];
                const writeBuffer = this.fbos[1 - this.currentBuffer];
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, writeBuffer.framebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                gl.useProgram(this.bufferProgram);
                this.setupAttributes(this.bufferProgram);
                
                gl.uniform1f(this.bufferUniforms.time, time);
                gl.uniform2f(this.bufferUniforms.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.bufferUniforms.mouse, mouseX, mouseY);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readBuffer.texture);
                gl.uniform1i(this.bufferUniforms.buffer, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                this.currentBuffer = 1 - this.currentBuffer;
                
                // Pass 2: Image
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                gl.useProgram(this.imageProgram);
                this.setupAttributes(this.imageProgram);
                
                gl.uniform2f(this.imageUniforms.resolution, this.canvas.width, this.canvas.height);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, writeBuffer.texture);
                gl.uniform1i(this.imageUniforms.buffer, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // ============================================================
        // INPUT HANDLERS
        // ============================================================
        
        // Face tracking
        function initFaceTracking() {
            if (typeof Parallax === 'undefined') {
                return Promise.reject('Parallax library not loaded');
            }
            
            return Parallax.init(view => {
                state.targetX = view.x;
                state.targetY = -view.y;
                
                if (state.inputMode !== 'face') {
                    state.inputMode = 'face';
                    updateInputMode('Face Tracking');
                }
            }, {
                smoothEye: 0.85,
                smoothDist: 0.3,
                threshold: 0.75
            });
        }
        
        // Gyroscope
        function initGyroscope() {
            return new Promise((resolve, reject) => {
                if (!window.DeviceOrientationEvent) {
                    reject('No gyroscope');
                    return;
                }
                
                const handler = (e) => {
                    if (e.gamma === null) return;
                    
                    state.targetX = Math.max(-1, Math.min(1, e.gamma / 30));
                    state.targetY = Math.max(-1, Math.min(1, (e.beta - 45) / 30));
                    
                    if (state.inputMode !== 'gyro') {
                        state.inputMode = 'gyro';
                        updateInputMode('Motion');
                    }
                };
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', handler);
                                resolve();
                            } else {
                                reject('Permission denied');
                            }
                        })
                        .catch(reject);
                } else {
                    window.addEventListener('deviceorientation', handler);
                    // Check if we actually get data
                    setTimeout(() => {
                        if (state.inputMode !== 'gyro') {
                            reject('No gyro data');
                        }
                    }, 1000);
                    resolve();
                }
            });
        }
        
        // Touch
        function initTouch() {
            let lastX = 0, lastY = 0;
            let offsetX = 0, offsetY = 0;
            
            document.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
            
            document.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                const dx = (touch.clientX - lastX) / window.innerWidth * 4;
                const dy = (touch.clientY - lastY) / window.innerHeight * 4;
                
                offsetX = Math.max(-1, Math.min(1, offsetX + dx));
                offsetY = Math.max(-1, Math.min(1, offsetY - dy));
                
                state.targetX = offsetX;
                state.targetY = offsetY;
                
                lastX = touch.clientX;
                lastY = touch.clientY;
            }, { passive: true });
            
            state.inputMode = 'touch';
            updateInputMode('Touch');
        }
        
        // Mouse
        function initMouse() {
            document.addEventListener('mousemove', (e) => {
                state.targetX = (e.clientX / window.innerWidth - 0.5) * 2;
                state.targetY = -(e.clientY / window.innerHeight - 0.5) * 2;
            });
            
            state.inputMode = 'mouse';
            updateInputMode('Mouse');
        }
        
        function updateInputMode(mode) {
            document.getElementById('inputMode').textContent = mode;
        }

        // ============================================================
        // MAIN
        // ============================================================
        let depthRenderer, prismRenderer;
        
        async function init() {
            // Initialize renderers
            depthRenderer = new DepthParallaxRenderer(document.getElementById('depthCanvas'));
            prismRenderer = new PrismRenderer(document.getElementById('prismCanvas'));
            
            // Load and setup
            try {
                await depthRenderer.init(CONFIG.imagePath, CONFIG.depthPath);
                prismRenderer.init();
            } catch (e) {
                console.error('Failed to initialize:', e);
                return;
            }
            
            // Start render loop
            function render() {
                // Smooth input values
                state.viewX += (state.targetX - state.viewX) * CONFIG.smoothing;
                state.viewY += (state.targetY - state.viewY) * CONFIG.smoothing;
                
                depthRenderer.render();
                prismRenderer.render();
                
                requestAnimationFrame(render);
            }
            render();
            
            // Initialize input (cascade)
            initInputMethods();
        }
        
        async function initInputMethods() {
            // Try face tracking
            try {
                await initFaceTracking();
                console.log('Face tracking initialized');
                return;
            } catch (e) {
                console.log('Face tracking unavailable:', e);
            }
            
            // Try gyroscope (mobile)
            if ('ontouchstart' in window) {
                try {
                    await initGyroscope();
                    console.log('Gyroscope initialized');
                    return;
                } catch (e) {
                    console.log('Gyroscope unavailable:', e);
                }
                
                // Touch fallback
                initTouch();
                return;
            }
            
            // Mouse fallback (desktop)
            initMouse();
        }
        
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>